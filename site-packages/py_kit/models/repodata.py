# -*- coding: utf-8 -*-


import datetime
import gzip
import io
import os
import json
import pathlib
import urllib.request
import urllib.parse
import logging

logger = logging.getLogger('cve-ease')

_ns = {
    'common': 'http://linux.duke.edu/metadata/common',
    'repo': 'http://linux.duke.edu/metadata/repo',
    'rpm': 'http://linux.duke.edu/metadata/rpm'
}


class Repos:
    __slots__ = ['_metadata', '_local_metadata']

    def __init__(self):
        self._metadata = {}
        self._local_metadata = {}

    def addrepo(self, url, isopath):
        if url in self._metadata:
            print("%s already exists!" % url)
        else:
            self._metadata[url] = self.load(url)
            if isopath is not None:
                if os.path.exists(isopath):
                    self._local_metadata[url] = self.loadlocal(isopath)
                else:
                    logger.error("Error: %s not exists!" % isopath)

    def load(self, baseurl):
        try:
            from defusedxml.ElementTree import fromstring
        except Exception:
            print(
                "Error: this tool depends on defusedxml, "
                "you can run 'sudo yum install -y python3-defusedxml' to install it"
            )
            exit(1)
        # parse baseurl to allow manipulating the path
        base = urllib.parse.urlparse(baseurl)
        path = pathlib.PurePosixPath(base.path)

        # first we must get the repomd.xml file
        repomd_path = path / 'repodata' / 'repomd.xml'
        repomd_url = base._replace(path=str(repomd_path)).geturl()
        print("repomd_url" ,repomd_url)
        # download and parse repomd.xml
        with urllib.request.urlopen(repomd_url) as response:
            repomd_xml = fromstring(response.read())

        # determine the location of *primary.xml.gz
        primary_element = repomd_xml.find('repo:data[@type="primary"]/repo:location', namespaces=_ns)
        primary_path = path / primary_element.get('href')
        primary_url = base._replace(path=str(primary_path)).geturl()

        # download and parse *-primary.xml
        with urllib.request.urlopen(primary_url) as response:
            with io.BytesIO(response.read()) as compressed:
                with gzip.GzipFile(fileobj=compressed) as uncompressed:
                    metadata = fromstring(uncompressed.read())

        return Repo(baseurl, metadata)

    def loadlocal(self, isopath):
        """
        load local repo
        :param path:
        :return:
        """
        try:
            from defusedxml.ElementTree import fromstring
        except Exception:
            print(
                "Error: this tool depends on defusedxml, "
                "you can run 'sudo yum install -y python3-defusedxml' to install it"
            )
            exit(1)

        base = urllib.parse.urlparse(isopath)
        path = pathlib.PurePosixPath(base.path)
        repomd_path = path / 'repodata' / 'repomd.xml'
        repomd_url = base._replace(path=str(repomd_path)).geturl()
        print("local_iso_path" ,repomd_url)
        # download and parse repomd.xml
        with open(repomd_url, 'r') as file:
            repomd_xml = fromstring(file.read())
        
        primary_element = repomd_xml.find('repo:data[@type="primary"]/repo:location', namespaces=_ns)
        primary_path = path / primary_element.get('href')
        primary_url = base._replace(path=str(primary_path)).geturl()

        with open(primary_url, 'rb') as file:
            with io.BytesIO(file.read()) as compressed:
                with gzip.GzipFile(fileobj=compressed) as uncompressed:
                    metadata = fromstring(uncompressed.read())

        return Repo(isopath, metadata)

    def list(self):
        result_list = []
        for url, repo in self._metadata.items():
            local_repo = self._local_metadata[url]
            query_s = repo.list()
            local_query_s = set(local_repo.list())
            for index, pkg in enumerate(query_s):
                print("[%6d/%-6d] parsing: %s!" % (index + 1, len(query_s), pkg.rpmname))
                if pkg in local_query_s:
                    result_list.append((True, pkg))
                else:
                    result_list.append((False, pkg))
        return result_list

    def find(self, name):
        """
        just find first one
        :param name:
        :return:
        """
        for url, repo in self._metadata.items():
            results = repo.findall(name)
            if results:
                return (url, results[-1])
        return None

    def findall(self, name):
        result_list = []
        for url, repo in self._metadata.items():
            query_s = repo.findall(name)
            for pkg in query_s:
                result_list.append((url, pkg))
        return result_list

    def findsrpms(self, name):
        result_set = set()
        for url, repo in self._metadata.items():
            query_s = repo.findsrpms(name)
            if query_s:
                result_set = set.union(result_set, query_s)
        return result_set





class Repo:
    """A dnf/yum repository."""

    __slots__ = ['baseurl', '_metadata']

    def __init__(self, baseurl, metadata):
        self.baseurl = baseurl
        self._metadata = metadata

    def __repr__(self):
        return f'<{self.__class__.__name__}: "{self.baseurl}">'

    def __str__(self):
        return self.baseurl

    def __len__(self):
        return int(self._metadata.get('packages'))

    def __iter__(self):
        for element in self._metadata:
            yield Package(element)

    def list(self):
        return [
            Package(element)
            for element in self._metadata.findall(f'common:package', namespaces=_ns)
        ]

    def find(self, name):
        results = self._metadata.findall(f'common:package[common:name="{name}"]', namespaces=_ns)
        if results:
            return Package(results[-1])
        else:
            return None

    def findall(self, name):
        return [
            Package(element)
            for element in self._metadata.findall(f'common:package[common:name="{name}"]', namespaces=_ns)
        ]

    def findsrpms(self, name):
        srpms_set = set()
        srpmslist_package = [
            Package(element)
            for element in self._metadata.findall(f'common:package[common:name="{name}"]', namespaces=_ns)
        ]
        for pkg in srpmslist_package:
            if pkg.sourcerpm not in srpms_set:
                srpms_set.add(pkg.sourcerpm)
        return srpms_set


class Package:
    """An RPM package from a repository."""
    BLACK_LIST = ['kernel', 'qemu', 'python-bottle', 'python-lxml', 'python-paramiko']
    ALIAS_NAME = {
        'vim': 'vim-enhanced'
    }
    __slots__ = ['_element']

    def __init__(self, element):
        self._element = element

    @property
    def name(self):
        return self._element.findtext('common:name', namespaces=_ns)

    @property
    def rpmname(self):
        return os.path.basename(self._element.find('common:location', namespaces=_ns).get('href'))

    @property
    def arch(self):
        return self._element.findtext('common:arch', namespaces=_ns)

    @property
    def summary(self):
        return self._element.findtext('common:summary', namespaces=_ns)

    @property
    def description(self):
        return self._element.findtext('common:description', namespaces=_ns)

    @property
    def packager(self):
        return self._element.findtext('common:packager', namespaces=_ns)

    @property
    def url(self):
        return self._element.findtext('common:url', namespaces=_ns)

    @property
    def license(self):
        return self._element.findtext('common:format/rpm:license', namespaces=_ns)

    @property
    def vendor(self):
        return self._element.findtext('common:format/rpm:vendor', namespaces=_ns)

    @property
    def sourcerpm(self):
        return self._element.findtext('common:format/rpm:sourcerpm', namespaces=_ns)

    @property
    def sname(self):
        sourcerpm = self._element.findtext('common:format/rpm:sourcerpm', namespaces=_ns)
        (name, _, _, _, _) = Package.splitRPM(sourcerpm)
        return name

    @property
    def sver(self):
        sourcerpm = self._element.findtext('common:format/rpm:sourcerpm', namespaces=_ns)
        (_, ver, _, _, _) = Package.splitRPM(sourcerpm)
        return ver

    @property
    def srel(self):
        sourcerpm = self._element.findtext('common:format/rpm:sourcerpm', namespaces=_ns)
        (_, _, rel, _, _) = Package.splitRPM(sourcerpm)
        return rel

    @property
    def sepoch(self):
        sourcerpm = self._element.findtext('common:format/rpm:sourcerpm', namespaces=_ns)
        (_, _, _, epoch, _) = Package.splitRPM(sourcerpm)
        return epoch

    @property
    def sarch(self):
        sourcerpm = self._element.findtext('common:format/rpm:sourcerpm', namespaces=_ns)
        (_, _, _, _, arch) = Package.splitRPM(sourcerpm)
        return arch

    @property
    def build_time(self):
        build_time = self._element.find('common:time', namespaces=_ns).get('build')
        return datetime.datetime.fromtimestamp(int(build_time))

    @property
    def location(self):
        return self._element.find('common:location', namespaces=_ns).get('href')

    @property
    def _version_info(self):
        return self._element.find('common:version', namespaces=_ns)

    @property
    def epoch(self):
        return self._version_info.get('epoch')

    @property
    def version(self):
        return self._version_info.get('ver')

    @property
    def release(self):
        return self._version_info.get('rel')

    @property
    def vr(self):
        version_info = self._version_info
        v = version_info.get('ver')
        r = version_info.get('rel')
        return f'{v}-{r}'

    @property
    def nvr(self):
        return f'{self.name}-{self.vr}'

    @property
    def evr(self):
        version_info = self._version_info
        e = version_info.get('epoch')
        v = version_info.get('ver')
        r = version_info.get('rel')
        if int(e):
            return f'{e}:{v}-{r}'
        else:
            return f'{v}-{r}'

    @property
    def nevr(self):
        return f'{self.name}-{self.evr}'

    @property
    def nevra(self):
        return f'{self.nevr}.{self.arch}'

    @property
    def _nevra_tuple(self):
        return self.name, self.epoch, self.version, self.release, self.arch

    @staticmethod
    def splitRPM(filename):
        if filename[-4:] == '.rpm':
            filename = filename[:-4]

        archIndex = filename.rfind('.')
        arch = filename[archIndex + 1:]

        relIndex = filename[:archIndex].rfind('-')
        rel = filename[relIndex + 1:archIndex]

        verIndex = filename[:relIndex].rfind('-')
        ver = filename[verIndex + 1:relIndex]

        epochIndex = filename.find(':')
        if epochIndex == -1:
            epoch = ''
        else:
            epoch = filename[:epochIndex]

        name = filename[epochIndex + 1:verIndex]
        return name, ver, rel, epoch, arch

    def __eq__(self, other):
        return self._nevra_tuple == other._nevra_tuple

    def __hash__(self):
        return hash(self._nevra_tuple)

    def __repr__(self):
        return f'<{self.__class__.__name__}: "{self.nevra}">'

    def __str__(self):
        data = {}
        for property in dir(self):
            if isinstance(property, str) and not property.startswith('_'):
                data[property] = getattr(self, property)
        return json.dumps(data, indent=4, default=str)
